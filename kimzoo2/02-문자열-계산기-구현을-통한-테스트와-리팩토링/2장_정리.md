# 2장 문자열 계산기 구현을 통한 테스트와 리팩토링

## 프로덕션 코드와 테스트 코드
- 프로덕션 코드와 테스트 코드는 파일을 분리 시킨다. 테스트 코드는 테스트 단계에서만 필요하기 때문에 서비스 시점에 같이 배포할 필요가 없기 때문이다.
- 테스트를 콘솔에 프린트하지 말자. 개발자가 수동으로 확인하는 것은 휴먼 에러가 발생할 확률을 높인다.

### @Before를 사용하는 이유
- @Before 객체를 사용해야 @Runwith, @Rule로 초기화된 객체에 접근이 가능하다.
- JUnit5부터는 @BeforeEach로 대체되었다.

_@RunWith_
- 테스트의 실행방법을 확장할 때 사용하는 어노테이션
- ex)` @RunWith(SpringRunner.class)`
- Junit5부터는 **@ExtendWith**로 대체되었다.

_@Rule_
- 테스트 클래스의 동작 방식을 재정의하거나 확장할 때 사용하는 어노테이션
- ex) `@Rule public Timeout timeout = Timeout.seconds(1);`

## 문자열 계산기 요구사항 실습
### 요구사항
- 쉼표 또는 콜론을 구분자로 가지는 문자열을 전달하는 경우 구분자를 기준으로 분리한 각 숫자의 합을 반환한다.
- 앞의 기본 구분자 외에 커스텀 구분자를 지정할 수 있다. 커스텀 구분자는 문자열 앞부분의 "//"와 "\n" 사이에 위치하는 문자를 커스텀 구분자로 사용한다.
- 예를 들어, "//;\n1;2;3"과 같이 값을 입력할 경우 커스텀 구분자는 세미콜론(;)이며, 결과 값은 6이 반환되어야 한다.
- 문자열 계산기에 음수를 전달하는 경우 RuntimeException으로 예외 처리해야 한다.

### 실습 후 리팩토링에 대해서
_리팩토링_
- 유지보수성과 가독성을 높이기 위해 소스코드의 구조를 변경하는 것이다.
- 기능이 변경되는 것이 아니다. AS-IS와 TO-BE는 동일한 결과를 가져야 한다.
- 요구사항 변경으로 **메소드 이름, 변수 이름을 변경하는 것도 리팩토링**이다.

**깔끔하고 읽기 좋은 코드를 구현하기 위해서는 극단적인 리팩토링을 통한 연습 또한 필요하다.**
